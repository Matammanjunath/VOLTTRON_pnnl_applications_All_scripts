# Allows forward reference linking so we can use type hints to classes that
# have NOT been created yet
from __future__ import annotations

import dataclasses
from dataclasses import dataclass
from functools import lru_cache
from typing import List, Dict, Union, Optional, Tuple


@dataclass
class MatchProperty:
    match: str
    datatype: str


@dataclass
class SubDeviceProperty:
    """
    A SubDeviceProperty is used to contain sub devices from a
    specific unit.
    """
    subdevices: List[str]

    def __init__(self, subdevlist: List[str]):
        if not isinstance(subdevlist, list):
            raise ValueError("subdevicelist requires list of sub-devices")

        for c in subdevlist:
            c = c.strip()
            if not isinstance(c, str):
                raise ValueError(f"subdevicelist has invalid string value in list {c}")
            if c[0].isnumeric():
                raise ValueError(f"subdevicelist cannot start with a number.")

        self.subdevices = [x for x in subdevlist]

    def __getitem__(self, item):
        return self.subdevices[item]

    def __iter__(self):
        return self.subdevices.__iter__()


@dataclass
class UnitProperty:
    """
    A UnitProperty has either a string reference or a List of
    strings as subdevices
    """
    unit: Union[str, SubDeviceProperty]
    units: List[str]

    def __init__(self, **kwargs):
        """
        Initialize the `UnitProperty` class with a concrete constructor instead
        of an autogenerated one that is what most of the other classes are using.

        Each argument in kwargs should have a `List[str]` type value.  The list will
        then be sent along to the Subdevice property.

        p = UnitProperty(rtu4=['sub1', 'sub2'], rtu5=['sub3', 'sub4'])
        print(p.rtu4[0])

        # prints sub1

        :param kwargs:
        """
        self.unit = {}
        self.units = []

        for k, v in kwargs.items():
            subd = SubDeviceProperty(v)
            setattr(self, k, subd)
            self.unit[k] = subd
            self.units.append(k)

    def __iter__(self):
        return self.units.__iter__()


@dataclass
class DeviceProperty:
    """
    A DeviceProperty contains the campus and building properties and
    a unit property.  The unit property is documented above.
    """
    campus: str
    building: str
    unit: str


@dataclass
class PointMapping:
    outdoor_air_temperature: str = "OutdoorAirTemperature"
    supply_fan_status: str = "SupplyFanStatus"
    supply_fan_speed_percent: str = "SupplyFanSpeedPercent"
    exhaust_fan_status: str = "ExhaustFanStatus"
    exhaust_fan_speed_percent: str = "ExhaustFanSpeedPercent"

    return_air_temperature: str = "ReturnAirTemperature"
    mixed_air_temperature: str = "MixedAirTemp"
    outdoor_damper_signal: str = "Damper"
    cool_call: str = "CompressorStatus"
    supply_fan_speed: str = "SupplyFanSpeed"
    heat_return_temperature: str = "HrWheelLeavingAirTemperature"
    heat_return_status: str = "HrWheelEnabled"
    discharge_temperature_set_point: str = "DischargeAirTemperatureSetPoint"

    def __hash__(self):
        value_str = ".".join([x.name for x in dataclasses.fields(self)])
        return value_str.__hash__()

    @lru_cache(maxsize=30)
    def get_keys(self) -> Tuple:
        return tuple([x.name for x in dataclasses.fields(self)])

    @lru_cache(maxsize=30)
    def get_value(self, name) -> str:
        if not hasattr(self, name):
            raise ValueError(f"Name: {name} not found on instance.")
        return dataclasses.asdict(self)[name]

    @lru_cache(maxsize=30)
    def get_values(self) -> Tuple:
        return tuple([self.get_value(x.name) for x in dataclasses.fields(self)])

    @lru_cache(maxsize=30)
    def get_key(self, value: str) -> str:
        for k in self.get_keys():
            if self.get_value(k) == value:
                return k

        raise ValueError(f"value: {value} not found on instance.")


@dataclass
class ArgumentsProperty:
    point_mapping: PointMapping

    def __init__(self, **kwargs):
        if 'point_mapping' in kwargs.keys():
            self.point_mapping = PointMapping(**kwargs['point_mapping'])
        else:
            self.point_mapping = PointMapping()

        for k, v in kwargs.items():
            if k != 'point_mapping':
                setattr(self, k, v)


@dataclass
class ConversionMapProperty:
    conversion_map: Optional[List[MatchProperty]]

    def __init__(self, mappings: List[dict]):
        self.conversion_map = []
        for k in mappings:
            match = k.get("match")
            datatype = k.get("datatype")
            if match:
                match = match.strip()
            if not match:
                raise ValueError("match required in conversion mapping")
            if datatype:
                datatype = datatype.strip()
            if not datatype:
                raise ValueError("datatype required in conversion mapping")
            self.conversion_map.append(MatchProperty(**k))


@dataclass
class AnalysisConfig:
    """
    AnalsyisConfig is a validator and documentation tool for the different
    configurations for pnnl applications.  It uses Prodict which allows
    dictionaries to seamlessly be written and read from using dot notation
    and allows for input validation based upon requirements.

    volttron-pnnl-application repository.
    """

    """ The application signature (probably should be removed but not sure)"""

    device: DeviceProperty
    analysis_name: str
    arguments: ArgumentsProperty
    actuation_mode: str

    def __post_init__(self):
        if isinstance(self.device, dict):
            self.device = DeviceProperty(**self.device)
        if self.actuation_mode is not None:
            self.actuation_mode = "PASSIVE"

    def __dict_to_sub_object__(self):
        if isinstance(self.device, dict):
            self.device = DeviceProperty(**self.device)
        if isinstance(self.arguments, dict):
            self.arguments = ArgumentsProperty(**self.arguments)

    def validate(self):
        self.__dict_to_sub_object__()
        required_properties = [
            ("device", DeviceProperty),
            ("arguments", ArgumentsProperty)
        ]

        errors = []
        # p = property, t = type
        # call will be isinstances(self, p, t)
        for p, t in required_properties:
            if not getattr(self, p):
                errors.append(f"Property '{p}' requires a value")
            elif not isinstance(getattr(self, p), t):
                errors.append(f"property '{p}' must be of type '{t}' was '{type(getattr(self, p))}")

        if getattr(self, "actuation_mode") not in ('PASSIVE', 'ACTIVE'):
            errors.append(f"property activatino_mode must be 'ACTIVE' or 'PASSIVE'")

        for v in ("campus", "building", "unit"):
            if not getattr(self.device, v):
                errors.append(f"property device.{v} not found")

        if errors:
            raise ValueError("\n".join(errors))

#
#
#
# class AnalysisConfig:
#     def __init__(self):
#         arguments_property = property("arguments", "A collection of dynamic parameters for data")
#         device_property = property("device", "Properties for the device this unit is going to be using")
#         unit_property = Nestedproperty("unit",
#                                        "Contains unit definition (can include subdevices)")
#         self.required_properties: List[Union[Property, NestedProperty]] = [
#             Property("application",
#                      "Application string that uniquely identifies this agent??"),
#             Property("analysis_name", "The name of the analysis that is being run"),
#             NestedProperty(arguments_property, "point_mapping",
#                            "A mapping of points used within the script to points on the message bus."),
#             Property("activation_mode",
#                      "PASSIVE or ACTIVE activation mode."),
#
#
#         ]
